// Vue-Router原理
// 路由就是SPA（单页应用）的路径管理器，路由用于设定访问路径，并将路径和组件映射起来
// 传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系

// SPA
// 单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。
// 1.hash
// hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 onhashchange 事件(监测hash值变化)，可以在 window 对象上监听这个事件

// 2.history模式
// 利用h5 history api pushState()和replaceState()
// 这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求。
// 要求后台配置，避免匹配不到的路由报404

export default routes = [
  {path: '/', name: 'homeLink', component: Home},
  {path: '/register', name: 'registerLink', component: Register},
  {path: '*', redirect: '/'}
]

// 为什么data要写成函数，不允许写成对象
// 1.data是Vue实例上的一个属性 2.对象是对于内存地址的引用 3.函数有自己的作用域
// JS 的数据类型分为基本类型和引用类型，基本类型存储在栈内存中，引用类型存储在堆内存中，并且引用类型指向的是栈内存中的堆区地址

// 对象是对栈内存的地址的引用，所以不同的对象的地址是不同的
// Vue 里面data属性之所以不能写成对象的格式，是因为对象是对地址的引用，而不是独立存在的。如果一个.vue 文件有多个子组件共同接收一个变量的话，改变其中一个子组件内此变量的值，会影响其他组件的这个变量的值。如果写成函数的话，那么他们有一个作用域的概念在里面，相互隔阂，不受影响。

// vue数据劫持
// setter,getter,数据观测

// Vue实例中数组改变 `length` 或下标直接赋值什么不能更新视图？

// 只要是因为 Vue 提取了数组的可以改变原数组的原生方法，进行了再加工。只有经过 Vue 处理过的方法才有更新视图的能力。

// vue 中this.$router.go(-1)，想带参数，返回上一页的tab,vuex,activated()钩子，eventBus